## General Makefile used to compile the modules
## This is included by all Makefiles, after they have defined the
## two variables
##    EPENDENCIES: list of modules we depend on
##    MODULE:       name of the module (to build libraires)


###########
## Five Makefile targets will be available from the command line:
##
##  all:        build objects and tests
##  all_obj:    build all objects, but not tests
##  clean:      remove all object and temporary files
##  test:       build the test programs found in the subdirectory test/
##  lib:        build a library with the objects
##              and install in the subdirectory lib/
##              It create a library called lib${MODULE}.a library
##  shared_lib: build a shared library with the objects
##              and install in the subdirectory lib/
##              It create a library called lib${MODULE}.so library
##
##  This makefile will not work with make other that GNU make
##
##  You can also add special flags to the compiler (e.g -gnatf) by
##  overriding the CFLAGS variable, as in
##        >  CFLAGS="-gnatf" make
###########

###########
# This Makefile can build libraries, that can be used later on by other
# modules by using:
#    gnatmake .... -aO<dir>/lib  -largs -l${MODULE}
###########

# Test programs to build
# These are all the programs in the test/ directory, whose name is test*.adb
TESTS=${wildcard test/test*.adb}
TEST_PROGS=${TESTS:%.adb=%}

DEP_SRC=${DEPENDENCIES:%=-aI../../%/}
DEP_OBJ=${DEPENDENCIES:%=-aO../../%/obj}


CFLAGS=
BIND_FLAGS=-E
GNATMAKE_FLAGS=-m -g -gnata $(CFLAGS)
COMPILER=gcc -c

SRC=${wildcard *.ads}
OBJ=${sort ${SRC:%.ads=%.o}}

SHELL=sh

.PHONY: clean all all_obj dirs lib shared_lib

all:: dirs all_obj test
all_obj:: dirs ${OBJ}
test: ${TEST_PROGS}

dirs: force
	@-mkdir -p obj
	@-mkdir -p test
	@-mkdir -p lib

# This target is fairly complicated: it recompiles a single Ada file, if it
# wasn't up-to-date (gnatmake -u), and stops as soon as one of the files could
# not be compiled (thus the use of "MAKEsuccess", since grep would disturb
# the result)
# We also want to show the "gcc" command every time a file is actually compiled
# but hide the "gnatmake: object up to date" message when a file doesn't need
# to be compiled. The problem is that in the pipe A | B we want the output
# status of A, not of B, thus the fairly complicated shell command.

ifneq (${COMPILER},gcc -c)
${OBJ}: force
	@cd obj; \
	exec 3>&1; \
	status=`((${COMPILER} ${DEP_SRC} -I.. -I../..\
	  ${@:%.o=%} $(GNATMAKE_FLAGS) 2>&1 1>&3 3>&- 4>&-; echo $$? >&4) |\
	  grep -v "gnatmake: object up to date." 1>&2 3>&- 4>&-) 4>&1`; \
	exit $$status
else
%.o: %.adb %.ads
	${COMPILER} ${DEP_SRC} -I.. ${@:%.o=%.adb} -o obj/$@
%.o: %.ads
	${COMPILER} ${DEP_SRC} -I.. ${@:%.o=%.ads} -o obj/$@
endif

${TEST_PROGS}: force
	cd test; gnatmake ${DEP_SRC} ${DEP_OBJ} \
	  -aI.. -aI../.. -aO../obj ${@:test/%=%} ${GNATMAKE_FLAGS} \
          -bargs ${BIND_FLAGS} 

lib: ${OBJ}
	@-cd lib; ${RM} *.ali
	cd obj; ar rc ../lib/lib${MODULE}.a *.o
	ranlib lib/lib${MODULE}.a
	@cd lib; cp ../obj/*.ali .
	@cd lib; chmod -w *.ali

shared_lib: ${OBJ}
	@-cd lib; ${RM} *.ali
	cd obj; gcc -shared -o ../lib/lib${MODULE}.so *.o
	@cd lib; cp ../obj/*.ali .
	@cd lib; chmod -w *.ali

clean: force
	-cd obj; ${RM} *.o *.ali
	-cd test; ${RM} *.o *.ali b~*
	-${RM} ${TEST_PROGS}
	-cd lib; ${RM} *.a *.so *.ali *.so
	@-rmdir lib
	@-rmdir obj

force:
